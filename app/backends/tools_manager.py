"""
Tool management functionality for backends.

This module provides a reusable ToolManager class that handles:
- Tool initialization and registration
- Tool schema generation for OpenAI-compatible APIs
- Tool execution
- Media backend integration
"""

from typing import Dict, Any
from .tools import get_all_tools
from .tools.ToolBase import ToolResult


TOOL_RULES = "\nResponses from tool calls are considered a primary source of truth. Use the provided tools first when possible to fulfill the user's request. You must call tools to get information about the real world or to perform actions. Images generated by tools are shown along side your response. Unless the tool actually returns a URL, assume that the image is being shown to the user and DO NOT attempt to link to it. Use multiple tool calls to the same tool if necessary to fulfill requests. Report any and all errors calling tools."
TOOL_CALL_TEMP = 0.1  # Low temperature for tool calls to ensure deterministic behavior


class ToolManager:
    """Manages tool initialization, execution, and schema generation."""

    def __init__(self, backend, console, config: Dict[str, Any]):
        """
        Initialize the ToolManager.

        Args:
            backend: The backend instance (e.g., Openai instance)
            console: Rich console for logging
            config: Configuration dict containing tool settings
        """
        self.backend = backend
        self.console = console
        self.config = config
        self.media_backend = None
        self.available_tools: Dict[str, Any] = {}
        self.tools_enabled = True
        self.tools_supported = True  # Track if endpoint supports tools

    def initialize(self, tools_enabled: bool = True) -> None:
        """
        Initialize and register available tools.

        Args:
            tools_enabled: Whether tools should be enabled
        """
        self.tools_enabled = tools_enabled

        if not tools_enabled:
            self.console.log("[yellow]Tools disabled in config")
            return

        all_tools = get_all_tools()
        for tool_name, tool_factory in all_tools.items():
            try:
                # Instantiate tool with access to backend and media backend
                # Works for both class-based and decorator-based tools
                tool_instance = tool_factory(
                    backend=self.backend,
                    media_backend=self.media_backend,
                    console=self.console,
                )
                self.available_tools[tool_name] = tool_instance
                self.console.log(f"- [green]Registered tool: {tool_name}")
            except Exception as e:
                self.console.log(f"[yellow]Failed to initialize tool {tool_name}: {e}")

    def update_media_backend(self, media_backend) -> None:
        """
        Update media_backend reference in all tools after it's created.

        Args:
            media_backend: The media backend instance to use for image generation
        """
        self.media_backend = media_backend

        # Update media_backend in all existing tool instances
        for tool_name, tool_instance in self.available_tools.items():
            tool_instance.media_backend = media_backend
            self.console.log(f"- [cyan]Updated media_backend for tool: {tool_name}")

    def get_tool_schemas(self) -> list:
        """
        Get OpenAI function schemas for all available tools.

        Returns:
            List of tool schemas in OpenAI format
        """
        return [tool.get_schema() for tool in self.available_tools.values()]

    def execute_tool(self, tool_name: str, arguments: dict) -> ToolResult:
        """
        Execute a tool and return its result.

        Args:
            tool_name: Name of the tool to execute
            arguments: Arguments to pass to the tool

        Returns:
            ToolResult containing the execution result
        """
        if tool_name not in self.available_tools:
            return ToolResult(text=f"Error: Tool '{tool_name}' not found")

        tool = self.available_tools[tool_name]
        try:
            result = tool.execute(**arguments)
            return result
        except Exception as e:
            self.console.log(f"[red]Error executing tool {tool_name}: {e}")
            return ToolResult(text=f"Error executing tool: {str(e)}")

    def is_enabled(self) -> bool:
        """Check if tools are enabled."""
        return self.tools_enabled

    def is_supported(self) -> bool:
        """Check if the endpoint supports tools."""
        return self.tools_supported

    def set_supported(self, supported: bool) -> None:
        """Set whether the endpoint supports tools."""
        self.tools_supported = supported

    def has_tools(self) -> bool:
        """Check if any tools are available."""
        return bool(self.available_tools)
